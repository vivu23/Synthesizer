{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { __awaiter } from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\n\nexport var OfflineContext = /*#__PURE__*/function (_Context) {\n  _inherits(OfflineContext, _Context);\n\n  function OfflineContext() {\n    var _this;\n\n    _classCallCheck(this, OfflineContext);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(OfflineContext).call(this, {\n      clockSource: \"offline\",\n      context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n      lookAhead: 0,\n      updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]\n    }));\n    _this.name = \"OfflineContext\";\n    /**\n     * An artificial clock source\n     */\n\n    _this._currentTime = 0;\n    _this.isOffline = true;\n    _this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];\n    return _this;\n  }\n  /**\n   * Override the now method to point to the internal clock time\n   */\n\n\n  _createClass(OfflineContext, [{\n    key: \"now\",\n    value: function now() {\n      return this._currentTime;\n    }\n    /**\n     * Same as this.now()\n     */\n\n  }, {\n    key: \"_renderClock\",\n\n    /**\n     * Render just the clock portion of the audio context.\n     */\n    value: function _renderClock(asynchronous) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var index, yieldEvery;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                index = 0;\n\n              case 1:\n                if (!(this._duration - this._currentTime >= 0)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                // invoke all the callbacks on that time\n                this.emit(\"tick\"); // increment the clock in block-sized chunks\n\n                this._currentTime += 128 / this.sampleRate; // yield once a second of audio\n\n                index++;\n                yieldEvery = Math.floor(this.sampleRate / 128);\n\n                if (!(asynchronous && index % yieldEvery === 0)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 9;\n                return new Promise(function (done) {\n                  return setTimeout(done, 1);\n                });\n\n              case 9:\n                _context.next = 1;\n                break;\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Render the output of the OfflineContext\n     * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var asynchronous = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var buffer;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.workletsAreReady();\n\n              case 2:\n                _context2.next = 4;\n                return this._renderClock(asynchronous);\n\n              case 4:\n                _context2.next = 6;\n                return this._context.startRendering();\n\n              case 6:\n                buffer = _context2.sent;\n                return _context2.abrupt(\"return\", new ToneAudioBuffer(buffer));\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Close the context\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      return Promise.resolve();\n    }\n  }, {\n    key: \"currentTime\",\n    get: function get() {\n      return this._currentTime;\n    }\n  }]);\n\n  return OfflineContext;\n}(Context);","map":null,"metadata":{},"sourceType":"module"}