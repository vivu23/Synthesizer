{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * // initialize the noise and start\n * const noise = new Tone.Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new Tone.AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\n\nexport var Noise = /*#__PURE__*/function (_Source) {\n  _inherits(Noise, _Source);\n\n  function Noise() {\n    var _this;\n\n    _classCallCheck(this, Noise);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Noise).call(this, optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"])));\n    _this.name = \"Noise\";\n    /**\n     * Private reference to the source\n     */\n\n    _this._source = null;\n    var options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n    _this._playbackRate = options.playbackRate;\n    _this.type = options.type;\n    _this._fadeIn = options.fadeIn;\n    _this._fadeOut = options.fadeOut;\n    return _this;\n  }\n\n  _createClass(Noise, [{\n    key: \"_start\",\n\n    /**\n     * internal start method\n     */\n    value: function _start(time) {\n      var _this2 = this;\n\n      var buffer = _noiseBuffers[this._type];\n      this._source = new ToneBufferSource({\n        url: buffer,\n        context: this.context,\n        fadeIn: this._fadeIn,\n        fadeOut: this._fadeOut,\n        loop: true,\n        onended: function onended() {\n          return _this2.onstop(_this2);\n        },\n        playbackRate: this._playbackRate\n      }).connect(this.output);\n\n      this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n    }\n    /**\n     * internal stop method\n     */\n\n  }, {\n    key: \"_stop\",\n    value: function _stop(time) {\n      if (this._source) {\n        this._source.stop(this.toSeconds(time));\n\n        this._source = null;\n      }\n    }\n    /**\n     * The fadeIn time of the amplitude envelope.\n     */\n\n  }, {\n    key: \"_restart\",\n    value: function _restart(time) {\n      // TODO could be optimized by cancelling the buffer source 'stop'\n      this._stop(time);\n\n      this._start(time);\n    }\n    /**\n     * Clean up.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Noise.prototype), \"dispose\", this).call(this);\n\n      if (this._source) {\n        this._source.disconnect();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"type\",\n\n    /**\n     * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n     * @example\n     * const noise = new Tone.Noise().toDestination().start();\n     * noise.type = \"brown\";\n     */\n    get: function get() {\n      return this._type;\n    },\n    set: function set(type) {\n      assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\n      if (this._type !== type) {\n        this._type = type; // if it's playing, stop and restart it\n\n        if (this.state === \"started\") {\n          var now = this.now();\n\n          this._stop(now);\n\n          this._start(now);\n        }\n      }\n    }\n    /**\n     * The playback rate of the noise. Affects\n     * the \"frequency\" of the noise.\n     */\n\n  }, {\n    key: \"playbackRate\",\n    get: function get() {\n      return this._playbackRate;\n    },\n    set: function set(rate) {\n      this._playbackRate = rate;\n\n      if (this._source) {\n        this._source.playbackRate.value = rate;\n      }\n    }\n  }, {\n    key: \"fadeIn\",\n    get: function get() {\n      return this._fadeIn;\n    },\n    set: function set(time) {\n      this._fadeIn = time;\n\n      if (this._source) {\n        this._source.fadeIn = this._fadeIn;\n      }\n    }\n    /**\n     * The fadeOut time of the amplitude envelope.\n     */\n\n  }, {\n    key: \"fadeOut\",\n    get: function get() {\n      return this._fadeOut;\n    },\n    set: function set(time) {\n      this._fadeOut = time;\n\n      if (this._source) {\n        this._source.fadeOut = this._fadeOut;\n      }\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Source.getDefaults(), {\n        fadeIn: 0,\n        fadeOut: 0,\n        playbackRate: 1,\n        type: \"white\"\n      });\n    }\n  }]);\n\n  return Noise;\n}(Source); //--------------------\n// THE NOISE BUFFERS\n//--------------------\n// Noise buffer stats\n\nvar BUFFER_LENGTH = 44100 * 5;\nvar NUM_CHANNELS = 2;\n/**\n * Cache the noise buffers\n */\n\nvar _noiseCache = {\n  brown: null,\n  pink: null,\n  white: null\n};\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\n\nvar _noiseBuffers = {\n  get brown() {\n    if (!_noiseCache.brown) {\n      var buffer = [];\n\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        var lastOut = 0.0;\n\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          var white = Math.random() * 2 - 1;\n          channel[i] = (lastOut + 0.02 * white) / 1.02;\n          lastOut = channel[i];\n          channel[i] *= 3.5; // (roughly) compensate for gain\n        }\n      }\n\n      _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.brown;\n  },\n\n  get pink() {\n    if (!_noiseCache.pink) {\n      var buffer = [];\n\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        var b0 = void 0,\n            b1 = void 0,\n            b2 = void 0,\n            b3 = void 0,\n            b4 = void 0,\n            b5 = void 0,\n            b6 = void 0;\n        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          var white = Math.random() * 2 - 1;\n          b0 = 0.99886 * b0 + white * 0.0555179;\n          b1 = 0.99332 * b1 + white * 0.0750759;\n          b2 = 0.96900 * b2 + white * 0.1538520;\n          b3 = 0.86650 * b3 + white * 0.3104856;\n          b4 = 0.55000 * b4 + white * 0.5329522;\n          b5 = -0.7616 * b5 - white * 0.0168980;\n          channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n          channel[i] *= 0.11; // (roughly) compensate for gain\n\n          b6 = white * 0.115926;\n        }\n      }\n\n      _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.pink;\n  },\n\n  get white() {\n    if (!_noiseCache.white) {\n      var buffer = [];\n\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          channel[i] = Math.random() * 2 - 1;\n        }\n      }\n\n      _noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.white;\n  }\n\n};","map":null,"metadata":{},"sourceType":"module"}