{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\thuyv\\\\Desktop\\\\Work\\\\UTSA\\\\Senior Design\\\\Synthesizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nvar DEFAULT_OPTIONS = {\n  channelCount: 2,\n  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  numberOfInputs: 1,\n  numberOfOutputs: 1,\n  parameterData: {},\n  processorOptions: {}\n};\nexport var createAudioWorkletNodeConstructor = function createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) {\n  return /*#__PURE__*/function (_audioNodeConstructor) {\n    _inherits(AudioWorkletNode, _audioNodeConstructor);\n\n    function AudioWorkletNode(context, name, options) {\n      var _this;\n\n      _classCallCheck(this, AudioWorkletNode);\n\n      var _a;\n\n      var nativeContext = getNativeContext(context);\n      var isOffline = isNativeOfflineAudioContext(nativeContext);\n      var mergedOptions = sanitizeAudioWorkletNodeOptions(_objectSpread({}, DEFAULT_OPTIONS, options)); // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n\n      testAudioWorkletNodeOptionsClonability(mergedOptions);\n      var nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n      var processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name); // Bug #186: Chrome, Edge and Opera do not allow to create an AudioWorkletNode on a closed AudioContext.\n\n      var nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== 'closed' ? nativeContext : (_a = getBackupOfflineAudioContext(nativeContext)) !== null && _a !== void 0 ? _a : nativeContext;\n      var nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n      var audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null;\n      /*\n       * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n       * returns false.\n       */\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(AudioWorkletNode).call(this, context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer));\n      var parameters = [];\n      nativeAudioWorkletNode.parameters.forEach(function (nativeAudioParam, nm) {\n        var audioParam = createAudioParam(_assertThisInitialized(_assertThisInitialized(_this)), isOffline, nativeAudioParam);\n        parameters.push([nm, audioParam]);\n      });\n      _this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n      _this._onprocessorerror = null;\n      _this._parameters = new ReadOnlyMap(parameters);\n      /*\n       * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n       * the destination.\n       */\n\n      if (isOffline) {\n        addUnrenderedAudioWorkletNode(nativeContext, _assertThisInitialized(_assertThisInitialized(_this)));\n      }\n\n      var _getAudioNodeConnecti = getAudioNodeConnections(_assertThisInitialized(_assertThisInitialized(_this))),\n          activeInputs = _getAudioNodeConnecti.activeInputs;\n\n      setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n      return _this;\n    }\n\n    _createClass(AudioWorkletNode, [{\n      key: \"onprocessorerror\",\n      get: function get() {\n        return this._onprocessorerror;\n      },\n      set: function set(value) {\n        var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n        this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n        var nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n        this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;\n      }\n    }, {\n      key: \"parameters\",\n      get: function get() {\n        if (this._parameters === null) {\n          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          return this._nativeAudioWorkletNode.parameters;\n        }\n\n        return this._parameters;\n      }\n    }, {\n      key: \"port\",\n      get: function get() {\n        return this._nativeAudioWorkletNode.port;\n      }\n    }]);\n\n    return AudioWorkletNode;\n  }(audioNodeConstructor);\n};","map":null,"metadata":{},"sourceType":"module"}